<html>
	<head>
	</head>
	<body>
		<h5>Link to Webpage: <a href=https://cal-cs184-student.github.io/sp22-project-webpages-RupaDuggirala/proj2/index.html>https://cal-cs184-student.github.io/sp22-project-webpages-RupaDuggirala/proj2/index.html</a></h5>
                    <h1 align="left">Overview</h1>
		    <p align="left">
                    </p>
                    <br>
                    <h1 align="left">Task 1: Bezier Curves with 1D de Casteljau Subdivision</h1>
		    <p align="left">
			    In its simplest form, de Casteljau’s algorithm provides a way to calculate the position of a point on a line segment. It utilizes linear interpolation between the two endpoints of a line segment to choose a point that is on the line, such that the ratio of the distance between one endpoint to this point and the total distance between the two endpoints is t; in the algorithm, t is a modifiable parameter within the range of (0, 1). This concept can be extended recursively in order to evaluate Bezier curves. Given a Bezier curve of degree n, de Casteljau’s algorithm can be used to form it by performing a linear interpolation between two curves of degree n - 1. Each of these n - 1 degree curves are formed by n control points, so a linear interpolation is calculated between each consecutive set of n - 1 points. Ultimately, another linear interpolation is calculated between those results in order to form the Bezier curve of degree n.
                    </p>
		    <p align="left">
			    This was done through the evaluateStep() function, which took in a vector of n control points as input. The function looped through these n points, and extracted each point i and its consecutive neighbor i + 1 to insert them into a linear interpolation equation with the parameter t. This yielded an intermediate point i’. All n of these intermediate points ultimately form the intermediate control points for the next subdivision level. Overall, these calculations are done recursively in order to relate the control points as a smooth, continuous Bezier curve.
                    </p>
		    <p align="left">
			    Here is a Bezier curve that we created, which has 6 control points. 
                    </p>
		    <img src="Task 1A.png">
		    <p align="left">
			    The following screenshots show each step, from the original 6 control points to the final evaluated point. 
                    </p>
		    <img src="Task 1B.png">
		    <img src="Task 1C.png">
		    <img src="Task 1D.png">
		    <img src="Task 1E.png">
		    <img src="Task 1F.png">
		    <p align="left">
			    These next two screenshots show the completed Bezier curve.
                    </p>
		    <img src="Task 1G.png">
		    <img src="Task 1H.png">
		    <p align="left">
			    Here is a slightly different Bezier curve, which we found by moving the original control points.
                    </p>
		    <img src="Task 1I.png">
		    <p align="left">
			    These next two screenshots illustrate the effect of modifying the parameter t, and how it impacts the positions of the control points and the final evaluated point on the curve. 
                    </p>
		    <img src="Task 1J.png">
		    <img src="Task 1K.png">
                    <br>
		    <h1 align="left">Task 2: Bezier Surfaces with Separable 1D de Casteljau</h1>
		    <p align="left">
			    Previously, de Casteljau’s algorithm was utilized recursively in 2D to perform repeated linear interpolation calculations on control points. This is how the Bezier curves from the previous task were derived. In this task, we were able to extend this logic to 3D in order to create Bezier surfaces.
                    </p>
		    <p align="left">
			    Foremost, the evaluateStep() function was utilized to calculate each step of de Casteljau’s algorithm. Similar to the 2D version, a vector of n control points was taken as input. The function looped through these points and performed a linear interpolation calculation on each consecutive pair. This yielded the intermediate control points for the next subdivision level. The only difference between the 2D and 3D versions of this function were in the use of Vector2D and Vector3D vectors for the points, as Bezier curves are formed from points in the x-y plane (or 2 coordinates) while Bezier surfaces are composed of points in the x-y-z plane (or 3 coordinates). Overall, this function repeats recursively in order to output a smooth, continuous Bezier curve from the initial control points for each level.
                    </p>
		    <p align="left">
			    This entire calculation is then done recursively. The evaluate1D() function is able to fully evaluate de Casteljau’s algorithm – it takes in a vector of points and loops through each of the n subdivision levels, calculating evaluateStep() using that level’s corresponding points and the parameter t as input. Ultimately, this yields a single point that lies on the Bezier curve at t. At last, the evaluate() function utilizes the two aforementioned functions in order to transform the Bezier curves into a Bezier surface. Given an n-by-n “grid” of control points, the function loops through each row and evaluates de Casteljau’s algorithm on it using the parameter u. This yields n intermediate points in total, which form a Bezier curve characterized by u. Then, de Casteljau’s algorithm is evaluated on this “moving” Bezier curve using the parameter v. This yields a single point that lies on the corresponding Bezier surface at the parameters u and v.
                    </p>
		    <p align="left">
			    Therefore, de Casteljau’s algorithm is performed recursively on each level of the n-by-n “grid” of control points in order to transform the Bezier curves into a Bezier surface. This is known as the separable 1D de Casteljau’s algorithm. 
                    </p>
		    <p align="left">
			    Here is a screenshot of bez/teapot.bez, as evaluated by our implementation.
                    </p>
		    <img src="Task 2A.png">
                    <br>
	</body>
</html>
